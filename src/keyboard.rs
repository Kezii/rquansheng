use dp32g030 as pac;

use embedded_hal::delay::DelayNs;

use crate::dp30g030_hal::gpio::{Input, Output, Pin, Port};

/// All keys supported by the reference firmware.
#[derive(Copy, Clone, Debug, Eq, PartialEq, defmt::Format)]
pub enum Key {
    Num0,
    Num1,
    Num2,
    Num3,
    Num4,
    Num5,
    Num6,
    Num7,
    Num8,
    Num9,
    Menu,
    Up,
    Down,
    Exit,
    Star,
    F,
    Ptt,
    Side2,
    Side1,
}

/// Key event generated by [`Keyboard::get_event`].
#[derive(Copy, Clone, Debug, Eq, PartialEq, defmt::Format)]
pub enum KeyEvent {
    KeyPressed(Key),
    KeyReleased(Key),
}

/// State for keypad event generation.
///
/// Kept separate from [`Keyboard`] so GPIOs can be dropped while the logical
/// state (last key + pending event) can be retained elsewhere.
#[derive(Copy, Clone, Debug, Eq, PartialEq, defmt::Format, Default)]
pub struct KeyboardState {
    last_key: Option<Key>,
    pending: Option<KeyEvent>,
}

// --- C pin mapping ----------------------------------------------------------

const GPIOA_PIN_KEYBOARD_0: u8 = 3;
const GPIOA_PIN_KEYBOARD_1: u8 = 4;
const GPIOA_PIN_KEYBOARD_2: u8 = 5;
const GPIOA_PIN_KEYBOARD_3: u8 = 6;

// Shared with I2C (bit-banged in the reference firmware)
const GPIOA_PIN_KEYBOARD_4: u8 = 10;
const GPIOA_PIN_KEYBOARD_5: u8 = 11;

// Shared with voice chip
const GPIOA_PIN_KEYBOARD_6: u8 = 12;
const GPIOA_PIN_KEYBOARD_7: u8 = 13;

#[derive(Copy, Clone)]
struct KeyPin {
    key: Option<Key>,
    pin: u8,
}

#[derive(Copy, Clone)]
struct KeyboardRow {
    /// 16-bit AND mask applied to GPIOA->DATA after setting all row pins high.
    set_to_zero_mask: u16,
    pins: [KeyPin; 4],
}

const KEYBOARD: [KeyboardRow; 5] = [
    KeyboardRow {
        // Zero row: special case (no row pulled low)
        set_to_zero_mask: 0xffff,
        pins: [
            KeyPin {
                key: Some(Key::Side1),
                pin: GPIOA_PIN_KEYBOARD_0,
            },
            KeyPin {
                key: Some(Key::Side2),
                pin: GPIOA_PIN_KEYBOARD_1,
            },
            // Duplicate to fill the array with valid values
            KeyPin {
                key: None,
                pin: GPIOA_PIN_KEYBOARD_1,
            },
            KeyPin {
                key: None,
                pin: GPIOA_PIN_KEYBOARD_1,
            },
        ],
    },
    KeyboardRow {
        // First row: pull PA10 low
        set_to_zero_mask: !(1u16 << GPIOA_PIN_KEYBOARD_4),
        pins: [
            KeyPin {
                key: Some(Key::Menu),
                pin: GPIOA_PIN_KEYBOARD_0,
            },
            KeyPin {
                key: Some(Key::Num1),
                pin: GPIOA_PIN_KEYBOARD_1,
            },
            KeyPin {
                key: Some(Key::Num4),
                pin: GPIOA_PIN_KEYBOARD_2,
            },
            KeyPin {
                key: Some(Key::Num7),
                pin: GPIOA_PIN_KEYBOARD_3,
            },
        ],
    },
    KeyboardRow {
        // Second row: pull PA11 low
        set_to_zero_mask: !(1u16 << GPIOA_PIN_KEYBOARD_5),
        pins: [
            KeyPin {
                key: Some(Key::Up),
                pin: GPIOA_PIN_KEYBOARD_0,
            },
            KeyPin {
                key: Some(Key::Num2),
                pin: GPIOA_PIN_KEYBOARD_1,
            },
            KeyPin {
                key: Some(Key::Num5),
                pin: GPIOA_PIN_KEYBOARD_2,
            },
            KeyPin {
                key: Some(Key::Num8),
                pin: GPIOA_PIN_KEYBOARD_3,
            },
        ],
    },
    KeyboardRow {
        // Third row: pull PA12 low
        set_to_zero_mask: !(1u16 << GPIOA_PIN_KEYBOARD_6),
        pins: [
            KeyPin {
                key: Some(Key::Down),
                pin: GPIOA_PIN_KEYBOARD_0,
            },
            KeyPin {
                key: Some(Key::Num3),
                pin: GPIOA_PIN_KEYBOARD_1,
            },
            KeyPin {
                key: Some(Key::Num6),
                pin: GPIOA_PIN_KEYBOARD_2,
            },
            KeyPin {
                key: Some(Key::Num9),
                pin: GPIOA_PIN_KEYBOARD_3,
            },
        ],
    },
    KeyboardRow {
        // Fourth row: pull PA13 low
        set_to_zero_mask: !(1u16 << GPIOA_PIN_KEYBOARD_7),
        pins: [
            KeyPin {
                key: Some(Key::Exit),
                pin: GPIOA_PIN_KEYBOARD_0,
            },
            KeyPin {
                key: Some(Key::Star),
                pin: GPIOA_PIN_KEYBOARD_1,
            },
            KeyPin {
                key: Some(Key::Num0),
                pin: GPIOA_PIN_KEYBOARD_2,
            },
            KeyPin {
                key: Some(Key::F),
                pin: GPIOA_PIN_KEYBOARD_3,
            },
        ],
    },
];

pub struct Keyboard {
    _col0: Pin<Input>,
    _col1: Pin<Input>,
    _col2: Pin<Input>,
    _col3: Pin<Input>,
    _row0: Pin<Output>,
    _row1: Pin<Output>,
    _row2: Pin<Output>,
    _row3: Pin<Output>,
}

impl Keyboard {
    pub fn init() -> Self {
        let peripherals = unsafe { pac::Peripherals::steal() };
        let syscon = &peripherals.SYSCON;
        let portcon = &peripherals.PORTCON;

        // Columns: PA3..PA6 as pull-up inputs.
        let col0 = Pin::new(Port::A, GPIOA_PIN_KEYBOARD_0).into_pull_up_input(syscon, portcon);
        let col1 = Pin::new(Port::A, GPIOA_PIN_KEYBOARD_1).into_pull_up_input(syscon, portcon);
        let col2 = Pin::new(Port::A, GPIOA_PIN_KEYBOARD_2).into_pull_up_input(syscon, portcon);
        let col3 = Pin::new(Port::A, GPIOA_PIN_KEYBOARD_3).into_pull_up_input(syscon, portcon);

        // Rows/shared: PA10..PA13 as push-pull outputs.
        let row0 = Pin::new(Port::A, GPIOA_PIN_KEYBOARD_4).into_push_pull_output(syscon, portcon);
        let row1 = Pin::new(Port::A, GPIOA_PIN_KEYBOARD_5).into_push_pull_output(syscon, portcon);
        let row2 = Pin::new(Port::A, GPIOA_PIN_KEYBOARD_6).into_push_pull_output(syscon, portcon);
        let row3 = Pin::new(Port::A, GPIOA_PIN_KEYBOARD_7).into_push_pull_output(syscon, portcon);

        Self {
            _col0: col0,
            _col1: col1,
            _col2: col2,
            _col3: col3,
            _row0: row0,
            _row1: row1,
            _row2: row2,
            _row3: row3,
        }
    }

    /// One-shot keypad scan (returns at most one key).
    pub fn poll<D: DelayNs>(&mut self, delay: &mut D) -> Option<Key> {
        let gpioa = unsafe { &*pac::GPIOA::ptr() };

        let mut key: Option<Key> = None;

        // Set all high: PA10..PA13
        let row_mask: u32 = (1u32 << GPIOA_PIN_KEYBOARD_4)
            | (1u32 << GPIOA_PIN_KEYBOARD_5)
            | (1u32 << GPIOA_PIN_KEYBOARD_6)
            | (1u32 << GPIOA_PIN_KEYBOARD_7);

        for row in KEYBOARD {
            // Set all high.
            gpioa
                .gpioa_data()
                .modify(|r, w| unsafe { w.bits(r.bits() | row_mask) });

            // Clear selected row pin (or none for the special "zero row").
            let and_mask = (row.set_to_zero_mask as u32) | 0xffff_0000;
            gpioa
                .gpioa_data()
                .modify(|r, w| unsafe { w.bits(r.bits() & and_mask) });

            // Read all 4 GPIO pins at once .. with de-noise, max of 8 sample loops.
            let mut stable_reads: u32 = 0;
            let mut samples: u32 = 0;
            let mut reg: u32 = 0;
            while stable_reads < 3 && samples < 8 {
                // Matches `SYSTICK_DelayUs(1)` in the C firmware.
                delay.delay_us(1);
                let reg2 = gpioa.gpioa_data().read().bits() & 0xffff;
                if reg == reg2 {
                    stable_reads += 1;
                } else {
                    stable_reads = 0;
                }
                reg = reg2;
                samples += 1;
            }

            if stable_reads < 3 {
                break; // noise is too bad
            }

            for kp in row.pins {
                let mask = 1u32 << kp.pin;
                if (reg & mask) == 0 {
                    key = kp.key;
                    break;
                }
            }

            if key.is_some() {
                break;
            }
        }

        // --- Post-scan cleanup (mirrors C firmware) -------------------------
        // Create I2C stop condition since we might have toggled I2C pins.
        // This leaves PA10/PA11 high.
        // Equivalent to `uv-k5-firmware-custom/driver/i2c.c:I2C_Stop()`.
        {
            // SDA low
            gpioa
                .gpioa_data()
                .modify(|r, w| unsafe { w.bits(r.bits() & !(1u32 << GPIOA_PIN_KEYBOARD_5)) });
            delay.delay_us(1);
            // SCL low
            gpioa
                .gpioa_data()
                .modify(|r, w| unsafe { w.bits(r.bits() & !(1u32 << GPIOA_PIN_KEYBOARD_4)) });
            delay.delay_us(1);
            // SCL high
            gpioa
                .gpioa_data()
                .modify(|r, w| unsafe { w.bits(r.bits() | (1u32 << GPIOA_PIN_KEYBOARD_4)) });
            delay.delay_us(1);
            // SDA high
            gpioa
                .gpioa_data()
                .modify(|r, w| unsafe { w.bits(r.bits() | (1u32 << GPIOA_PIN_KEYBOARD_5)) });
            delay.delay_us(1);
        }

        // Reset VOICE pins: PA12 low, PA13 high.
        gpioa
            .gpioa_data()
            .modify(|r, w| unsafe { w.bits(r.bits() & !(1u32 << GPIOA_PIN_KEYBOARD_6)) });
        gpioa
            .gpioa_data()
            .modify(|r, w| unsafe { w.bits(r.bits() | (1u32 << GPIOA_PIN_KEYBOARD_7)) });

        key
    }

    /// Return at most one key event (pressed/released).
    ///
    /// - Keeps minimal state (`last_key` + one pending event) to generate edges.
    /// - Never reports multiple simultaneous presses; only one key at a time.
    pub fn get_event<D: DelayNs>(
        &mut self,
        state: &mut KeyboardState,
        delay: &mut D,
    ) -> Option<KeyEvent> {
        if let Some(ev) = state.pending.take() {
            return Some(ev);
        }

        let cur = self.poll(delay);
        match (state.last_key, cur) {
            (None, None) => None,
            (None, Some(k)) => {
                state.last_key = Some(k);
                Some(KeyEvent::KeyPressed(k))
            }
            (Some(prev), None) => {
                state.last_key = None;
                Some(KeyEvent::KeyReleased(prev))
            }
            (Some(prev), Some(k)) if prev == k => None,
            (Some(prev), Some(k)) => {
                // Key changed without going idle: emit release first, queue press.
                state.last_key = Some(k);
                state.pending = Some(KeyEvent::KeyPressed(k));
                Some(KeyEvent::KeyReleased(prev))
            }
        }
    }
}
